# Фундаментальные концепции (принципы) ООП
* **Инкапсуляция** - это возможность объектов содержать в себе свойства и методы. Это процесс упаковки классов в открытый интерфейс и закрытую реализацию
* **Наследование** позволяет классу наследовать атрибуты и методы другого класса.
* **Полиморфизм** - означает, что схожие объекты способны по-разному отвечать на одно и то же сообщение. Возможность объектов с одинаковой спецификацией иметь различную реализацию.

#### Интерфейсы
В большинстве объектно-ориентированных языков программирования методы, являющиеся частью интерфейсов, определяются как public.
Интерфейсы содержат определения функций (то есть описание их сигнатур) без их реализации.
интерфейс -  это просто чистый абстрактный класс, то есть класс, в котором не определено ничего, кроме абстрактных методов
Интерфейс никогда не обеспечивает реализации какого-либо рода — только поведение


#### Абстрактный класc 
базовый класс, который не предполагает создания экземпляров. Грубо говоря, это класс-шаблон. Реализуют на практике полиморфизм. Абстрактный класс может содержать абстрактные методы и свойства
это класс, содержащий один или несколько методов, которые не имеют какой-либо обеспеченной реализации
Единственными методами, которые подкласс должен реализовать, являются те, что объявлены в суперклассе абстрактными. Эти абстрактные методы представляют собой контракт.
В некоторых языках для реализации контрактов используются только абстрактные классы, в некоторых - интерфейсы


Абстрактные классы включают абстрактные и конкретные методы, а интерфейсы содержат только абстрактные методы.
```
public interface Nameable {
    String getName();
    void setName (String aName);
}

public abstract class Mammal {
    public void generateHeat() {
        System.out.println("Выработка тепла");
    }
    public abstract void makeNoise();
}

public class Dog extends Mammal implements Nameable {
    String name;
    public void makeNoise(){
        System.out.println("Лай");
    }
    public void setName (String aName) {
        name = aName;
    }
    public String getName () {
        return (name);
    }
}

```



**конструктор** - точка входа для класса, где создается объект
**конструктор** должен задать для объекта его начальное, надежное состояние


# Разница между интерфейсом и реализацией
сконструированные классы состоят из двух частей
* интерфейса
* реализации

Рассмотрим автомобиль. Двигатель является частью **реализации**, а руль — частью **интерфейса**.
Изменения в реализации не должны оказывать влияния на водителя, в то время как изменения в интерфейсе могут это делать.

Услуги, предоставляемые конечным пользователям, образуют **интерфейс**.
Детали **реализации** скрыты от пользователей. изменения в реализации не должны требовать внесения изменений в пользовательский код
При проектировании класса общее правило заключается в том, чтобы всегда обеспечивать для пользователей как можно меньше информации о внутреннем устройстве этого класса
Технически все, что не является открытым интерфейсом, можно считать реализацией.

# Композиция
**Композиция**, как тоже видно из названия, подразумевает создание объектов с использованием других объектов
Пример - объект автомобиль состоит из мелких объектов, такик как двигатель, рама, колеса и тд.
В целом существует два типа композиции:
* **Агрегация** - это сложный объект, состоящий из других объектов 
```javascript
const car = {
    engine:{
        pistons:{},
        sparkPlugs:{}
    },
    stereo:{
        radio:{},
        cassette:{}
    },
    door:{
        handle:{}
    }
}
```
* **Ассоциация** - используется, когда одному объекту нужно, чтобы другой объект оказал ему услугу. (компьютерная система)


# Категорий шаблонов проектирования
* Порождающие — создают за вас объекты, чтобы вам не пришлось заниматься непосредственным созданием экземпляров объектов. Это позволит вашей программе проявлять большую гибкость при решении о том, какие объекты надлежит создать в конкретном случае.
    * Abstract factory (Абстрактная фабрика)
    * Builder (Строитель)
    * Factory method (Фабричный метод)
    * Prototype (Прототип)
    * Singleton (Одиночка)
   
* Структурные — помогают вам составлять из групп объектов более крупные структуры вроде комплексных интерфейсов пользователя или учетных данных.
    * Adapter (Адаптер);
    * Bridge (Мост);
    * Composite (Компоновщик);
    * Decorator (Декоратор);
    * Facade (Фасад);
    * Flyweight (Приспособленец);
    * Proxy (Заместитель).
* Поведенческие — помогают вам определять взаимодействие между объектами в вашей системе, а также способ управления потоком в комплектной программе.
    * Chain of response (Цепочка ответственности);
    * Command (Команда);
    * Interpreter (Интерпретатор);
    * Iterator (Итератор);
    * Mediator (Посредник);
    * Memento (Хранитель);
    * Observer (Наблюдатель);
    * State (Состояние);
    * Strategy (Стратегия);
    * Template method (Шаблонный метод);
    * Visitor (Посетитель).